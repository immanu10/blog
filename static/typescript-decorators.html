
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - TypeScript Decorators</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>21-Feb-2025</time>
</div>
<h1>TypeScript Decorators</h1>
<br>
<div id="blog-content"><p>Decorators provide a way to add metadata and modify classes, methods, properties, and parameters in TypeScript. They offer a declarative approach to enhancing code functionality without directly altering the original code structure.</p>

<p>Think of decorators as wrappers around your code elements. They allow you to inject additional logic before, after, or around the execution of the decorated element.  This can be useful for various tasks, including:</p>

<ul>
<li><strong>Logging:</strong> Track method calls and arguments.</li>
<li><strong>Access Control:</strong> Restrict access to certain methods or properties.</li>
<li><strong>Validation:</strong> Enforce data integrity before processing.</li>
<li><strong>Instrumentation:</strong> Measure performance or gather usage statistics.</li>
</ul>

<p>Here&rsquo;s a breakdown of how decorators work in TypeScript:</p>

<p><strong>1. Declaration:</strong></p>

<p>Decorators are prefixed with the <code>@</code> symbol followed by the decorator function.  They can be applied to classes, methods, properties, and parameters.</p>

<pre><code class="language-typescript">function myDecorator(target: any, propertyKey: string | symbol) {
  console.log(`Decorating property: ${String(propertyKey)}`);
}

class MyClass {
  @myDecorator
  myProperty: string = &quot;Hello&quot;;
}
</code></pre>

<p><strong>2. Decorator Factories:</strong></p>

<p>For more complex scenarios, you can use decorator factories. These are functions that return a decorator function, allowing you to pass arguments to the decorator.</p>

<pre><code class="language-typescript">function logDecorator(message: string) {
  return function (target: any, propertyKey: string | symbol) {
    const originalMethod = target[propertyKey];

    target[propertyKey] = function (...args: any[]) {
      console.log(message);
      const result = originalMethod.apply(this, args);
      return result;
    };
  };
}

class MyClass {
  @logDecorator(&quot;Calling myMethod&quot;)
  myMethod(arg1: string, arg2: number): string {
    return `${arg1} ${arg2}`;
  }
}

const instance = new MyClass();
instance.myMethod(&quot;Test&quot;, 123); // Output: &quot;Calling myMethod&quot;
</code></pre>

<p><strong>3. Method Decorators:</strong></p>

<p>Method decorators receive three arguments:</p>

<ul>
<li><code>target</code>: The prototype of the class.</li>
<li><code>propertyKey</code>: The name of the method.</li>
<li><code>descriptor</code>: A <code>PropertyDescriptor</code> containing information about the method.</li>
</ul>

<p><strong>4. Class Decorators:</strong></p>

<p>Class decorators receive one argument:</p>

<ul>
<li><code>constructor</code>: The constructor function of the class.</li>
</ul>

<p><strong>5. Property Decorators:</strong></p>

<p>Property decorators receive two arguments:</p>

<ul>
<li><code>target</code>: The prototype of the class or the constructor function if applied to a static property.</li>
<li><code>propertyKey</code>: The name of the property.</li>
</ul>

<p><strong>Example: Validation Decorator</strong></p>

<pre><code class="language-typescript">function validate(validator: (value: any) =&gt; boolean) {
  return function (target: any, propertyKey: string | symbol) {
    let value: any;

    Object.defineProperty(target, propertyKey, {
      get() {
        return value;
      },
      set(newValue) {
        if (!validator(newValue)) {
          throw new Error(&quot;Invalid value&quot;);
        }
        value = newValue;
      },
    });
  };
}

class User {
  @validate((value: string) =&gt; value.length &gt; 0)
  name: string = &quot;&quot;;
}

const user = new User();
user.name = &quot;John&quot;; // Valid
// user.name = &quot;&quot;; // Throws &quot;Invalid value&quot;
</code></pre>

<p>By leveraging decorators effectively, you can significantly improve code readability, maintainability, and extensibility in your TypeScript projects. They provide a powerful mechanism for separating concerns and applying cross-cutting logic in a clean and concise manner.</p>
</div>

    </main>
</body>
</html>
