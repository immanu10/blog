
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Lamport Timestamps</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>10-Feb-2025</time>
</div>
<h1>Lamport Timestamps</h1>
<br>
<div id="blog-content"><p>A Lamport timestamp is a simple numerical counter used to assign logical timestamps to events in a distributed system. Unlike physical clocks which can be difficult to synchronize across multiple machines, Lamport timestamps provide a way to order events based on their causal relationships. This ordering is crucial for ensuring data consistency and correctness in distributed applications.</p>

<p><strong>The Algorithm:</strong></p>

<ol>
<li><p><strong>Local Counter:</strong> Each process maintains a local counter initialized to 0.</p></li>

<li><p><strong>Increment on Event:</strong> Every time an event occurs at a process, the local counter is incremented by 1.</p></li>

<li><p><strong>Message Passing:</strong> When a process sends a message, it includes its current timestamp in the message.</p></li>

<li><p><strong>Receive and Update:</strong> Upon receiving a message, the recipient process updates its local counter by taking the maximum of its current counter and the received timestamp, and then increments its counter by 1.</p></li>
</ol>

<p><strong>Example in Go:</strong></p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

type Process struct {
    id          int
    timestamp   int
    messageChan chan Message
    mu          sync.Mutex
}

type Message struct {
    senderID   int
    timestamp   int
    messageContent string
}

func (p *Process) run() {
    for {
        select {
        case msg := &lt;-p.messageChan:
            p.mu.Lock()
            p.timestamp = max(p.timestamp, msg.timestamp) + 1
            fmt.Printf(&quot;Process %d received message from %d: %s (Timestamp: %d)\n&quot;, p.id, msg.senderID, msg.messageContent, p.timestamp)
            p.mu.Unlock()
        default:
            // Simulate some event happening
            time.Sleep(time.Millisecond * 500)
            p.mu.Lock()
            p.timestamp++
            fmt.Printf(&quot;Process %d: Internal Event (Timestamp: %d)\n&quot;, p.id, p.timestamp)
            p.mu.Unlock()

            // Simulate sending message to another process
             if p.id == 1{
                p2.messageChan &lt;- Message{senderID: p.id, timestamp: p.timestamp, messageContent: &quot;Hello from P1&quot;}
            }


        }
    }
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}

var p1, p2 Process

func main() {
    p1 = Process{id: 1, timestamp: 0, messageChan: make(chan Message)}
    p2 = Process{id: 2, timestamp: 0, messageChan: make(chan Message)}

    go p1.run()
    go p2.run()

    select {} // Keep the program running
}


</code></pre>

<p><strong>Limitations:</strong></p>

<p>Lamport timestamps only capture the <em>happens-before</em> relationship between events.  Concurrent events can have the same timestamp.  They do not provide true global time ordering.  For scenarios needing strong consistency guarantees about the actual time of events, more complex mechanisms like vector clocks are necessary.</p>
</div>

    </main>
</body>
</html>
