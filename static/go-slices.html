
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Go Slices</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>13-Jan-2025</time>
</div>
<h1>Go Slices</h1>
<br>
<div id="blog-content"><p>Go slices provide a powerful and flexible way to work with sequences of data.  They are dynamically sized, meaning they can grow or shrink as needed, unlike arrays which have a fixed size.  Understanding slices is crucial for writing efficient and idiomatic Go code.</p>

<p><strong>What are Slices?</strong></p>

<p>A slice is a dynamic view into an underlying array.  It&rsquo;s composed of three components:</p>

<ul>
<li><strong>Pointer:</strong> Points to the first element in the slice within the underlying array.</li>
<li><strong>Length:</strong> The number of elements in the slice.</li>
<li><strong>Capacity:</strong> The number of elements from the start of the slice to the end of the underlying array.</li>
</ul>

<p><strong>Creating Slices:</strong></p>

<p>There are several ways to create slices:</p>

<ul>
<li><strong>Using the <code>make</code> function:</strong>  <code>make([]T, length, capacity)</code> creates a slice of type <code>T</code> with the specified length and capacity. If capacity is omitted, it defaults to the length.</li>
</ul>

<pre><code class="language-go">numbers := make([]int, 5, 10) // Slice of ints, length 5, capacity 10
</code></pre>

<ul>
<li><strong>Slice literal:</strong> Similar to array literals, but without specifying the size.</li>
</ul>

<pre><code class="language-go">names := []string{&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;}
</code></pre>

<ul>
<li><strong>Slicing an existing array or slice:</strong>  <code>array[start:end]</code> creates a slice from <code>array</code> starting at index <code>start</code> up to (but not including) index <code>end</code>.</li>
</ul>

<pre><code class="language-go">arr := [5]int{1, 2, 3, 4, 5}
slice := arr[1:4] // Slice contains {2, 3, 4}
</code></pre>

<p><strong>Key Operations:</strong></p>

<ul>
<li><strong><code>append</code>:</strong> Adds elements to the end of a slice, increasing its length. If the capacity is reached, a new underlying array is allocated, and the data is copied.</li>
</ul>

<pre><code class="language-go">numbers := []int{1, 2, 3}
numbers = append(numbers, 4, 5) // numbers is now {1, 2, 3, 4, 5}
</code></pre>

<ul>
<li><strong><code>len</code>:</strong> Returns the length of the slice.</li>
</ul>

<pre><code class="language-go">count := len(numbers) // count is 5
</code></pre>

<ul>
<li><strong><code>cap</code>:</strong> Returns the capacity of the slice.</li>
</ul>

<pre><code class="language-go">capacity := cap(numbers) // Capacity may be greater than length
</code></pre>

<ul>
<li><strong><code>copy</code>:</strong> Copies elements from one slice to another.</li>
</ul>

<pre><code class="language-go">source := []int{1, 2, 3}
destination := make([]int, 3)
copy(destination, source) // destination is now {1, 2, 3}
</code></pre>

<p><strong>Important Considerations:</strong></p>

<ul>
<li><strong>Slices are reference types:</strong>  Modifying a slice may modify the underlying array, affecting other slices that share the same underlying array.</li>
<li><strong>Nil slices:</strong>  A nil slice has a length and capacity of zero and no underlying array.  It&rsquo;s often used as the initial value for a slice.</li>
<li><strong>Empty slices:</strong> An empty slice has a length of zero but may have a non-zero capacity and an underlying array. It&rsquo;s created using <code>make([]T, 0)</code> or <code>[]T{}</code>.</li>
</ul>

<p>By understanding these concepts and operations, you can effectively utilize slices to manage collections of data in your Go programs, leading to more efficient and dynamic code.</p>
</div>

    </main>
</body>
</html>
