
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Bloom Filters</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>12-Feb-2025</time>
</div>
<h1>Bloom Filters</h1>
<br>
<div id="blog-content"><p>A Bloom filter is a probabilistic data structure designed to efficiently test whether an element is present in a set.  It&rsquo;s optimized for speed and memory efficiency, but comes with a trade-off: it can return false positives, meaning it might indicate an element is present when it&rsquo;s not.  However, it will <em>never</em> return a false negative.  If a Bloom filter says an element is <em>not</em> present, it definitively isn&rsquo;t.</p>

<p><strong>How it Works:</strong></p>

<ol>
<li><p><strong>Initialization:</strong> A Bloom filter starts with a bit array of <code>m</code> bits, all initially set to 0.  It also uses <code>k</code> different hash functions, each of which maps an element to a position in the bit array.</p></li>

<li><p><strong>Insertion:</strong> To add an element, it&rsquo;s hashed by each of the <code>k</code> hash functions.  The bits at the corresponding indices in the bit array are then set to 1.</p></li>

<li><p><strong>Lookup:</strong> To check if an element is present, the element is again hashed by each of the <code>k</code> hash functions.  If all the bits at the calculated indices are 1, the Bloom filter reports that the element is <em>probably</em> present. If any of the bits are 0, the element is definitely <em>not</em> present.</p></li>
</ol>

<p><strong>Example (JavaScript):</strong></p>

<pre><code class="language-javascript">class BloomFilter {
  constructor(size, hashCount) {
    this.size = size;
    this.bits = new Array(size).fill(0);
    this.hashCount = hashCount;
    // Simple hash functions (for illustrative purposes only - in reality use better hash functions)
    this.hashFunctions = [
      (str) =&gt; str.charCodeAt(0) % size,
      (str) =&gt; str.charCodeAt(str.length - 1) % size,
      (str) =&gt; str.length % size,
    ]; 
  }

  add(item) {
    for (let i = 0; i &lt; this.hashCount; i++) {
      const index = this.hashFunctions[i](item);
      this.bits[index] = 1;
    }
  }

  contains(item) {
    for (let i = 0; i &lt; this.hashCount; i++) {
      const index = this.hashFunctions[i](item);
      if (this.bits[index] === 0) {
        return false; // Definitely not present
      }
    }
    return true; // Possibly present
  }
}

// Example usage:
const filter = new BloomFilter(10, 3);
filter.add(&quot;apple&quot;);
filter.add(&quot;banana&quot;);

console.log(filter.contains(&quot;apple&quot;)); // true
console.log(filter.contains(&quot;banana&quot;)); // true
console.log(filter.contains(&quot;grape&quot;)); // Possibly true (false positive)
console.log(filter.contains(&quot;orange&quot;)); // false
</code></pre>

<p><strong>Use Cases:</strong></p>

<ul>
<li><strong>Spell checkers:</strong> Quickly checking if a word is misspelled.</li>
<li><strong>Databases:</strong>  Reducing disk lookups by checking if a key exists in a cache before querying the database.</li>
<li><strong>Networking:</strong> Filtering out duplicate packets or requests.</li>
</ul>

<p><strong>Advantages:</strong></p>

<ul>
<li><strong>Space-efficient:</strong> Bloom filters require significantly less memory than storing all elements explicitly.</li>
<li><strong>Fast lookups:</strong> Checking for membership is very fast, regardless of the set size.</li>
</ul>

<p><strong>Disadvantages:</strong></p>

<ul>
<li><strong>False positives:</strong> The possibility of false positives needs to be considered in the application design.</li>
<li><strong>Deletion difficulty:</strong>  Removing elements from a Bloom filter is generally complex and can impact its accuracy.</li>
</ul>

<p>Bloom filters are a powerful tool when memory efficiency and lookup speed are paramount, even at the cost of potential false positives. They&rsquo;re a valuable asset in many applications where the absence of false negatives is crucial and the occasional false positive is acceptable.</p>
</div>

    </main>
</body>
</html>
