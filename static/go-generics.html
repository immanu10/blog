
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Go Generics</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>26-Apr-2025</time>
</div>
<h1>Go Generics</h1>
<br>
<div id="blog-content"><p>Go, known for its simplicity and efficiency, introduced generics in version 1.18.  Generics add a powerful dimension to Go&rsquo;s type system, enabling reusable code components that can work with various data types without compromising type safety.  Before generics, achieving this often involved using the empty <code>interface{}</code> type and runtime type assertions, which sacrificed compile-time safety and could lead to unexpected runtime errors.</p>

<p><strong>The Problem Generics Solve</strong></p>

<p>Imagine writing a function to find the maximum element in a slice.  Without generics, you&rsquo;d need to write separate functions for different types like <code>int</code>, <code>float64</code>, <code>string</code>, and so on. This leads to code duplication and maintenance overhead.</p>

<p><strong>Generics to the Rescue</strong></p>

<p>Generics allow you to define functions and data structures that operate on parameterized types. Let&rsquo;s rewrite the <code>max</code> function using generics:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func max[T comparable](slice []T) T {
	if len(slice) == 0 {
		var zero T
		return zero // Return the zero value of the type
	}

	maxVal := slice[0]
	for _, val := range slice[1:] {
		if val &gt; maxVal {
			maxVal = val
		}
	}
	return maxVal
}

func main() {
	ints := []int{1, 5, 2, 8, 3}
	fmt.Println(max(ints)) // Output: 8

	floats := []float64{2.5, 1.7, 9.2, 4.3}
	fmt.Println(max(floats)) // Output: 9.2

	strings := []string{&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;}
	fmt.Println(max(strings)) // Output: cherry
}

</code></pre>

<p>In this example, <code>max[T comparable]</code> declares a type parameter <code>T</code> constrained by <code>comparable</code>. This constraint ensures that the <code>&gt;</code> operator is valid for the type <code>T</code>. The function now works with any type that satisfies the <code>comparable</code> constraint.</p>

<p><strong>Type Constraints</strong></p>

<p>Constraints are crucial for ensuring type safety with generics. They define the permissible types for a type parameter.  Go provides several predefined constraints like <code>comparable</code>, <code>any</code> (equivalent to <code>interface{}</code>), and interfaces. You can also define custom constraints using interfaces.</p>

<pre><code class="language-go">type Number interface {
    int | float64
}

func add[T Number](a, b T) T {
    return a + b
}
</code></pre>

<p>Here, the <code>Number</code> constraint limits the type parameter <code>T</code> to either <code>int</code> or <code>float64</code>.</p>

<p><strong>Benefits of Generics</strong></p>

<ul>
<li><strong>Code Reusability:</strong> Write once, use with many types.</li>
<li><strong>Type Safety:</strong> Catch type errors at compile time, not runtime.</li>
<li><strong>Performance:</strong> Avoid boxing and unboxing associated with <code>interface{}</code>.</li>
<li><strong>Improved Code Clarity:</strong>  Express intentions clearly with type parameters.</li>
</ul>

<p>Go generics bring significant improvements to the language. While they introduce a bit of complexity, the benefits of code reusability, type safety, and performance make them a valuable addition for writing robust and maintainable Go code.</p>
</div>

    </main>
</body>
</html>
