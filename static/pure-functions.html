
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Pure Functions</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>05-Apr-2025</time>
</div>
<h1>Pure Functions</h1>
<br>
<div id="blog-content"><p>Pure functions are a cornerstone of functional programming paradigms, offering predictability and testability.  Understanding their characteristics is crucial for writing clean and maintainable code, especially in frontend frameworks like React.</p>

<p>A pure function adheres to two fundamental rules:</p>

<ol>
<li><p><strong>Given the same input, it always returns the same output.</strong>  This deterministic behavior eliminates side effects and ensures consistency.</p></li>

<li><p><strong>It produces no side effects.</strong>  A side effect is any modification outside the function&rsquo;s scope, such as changing a global variable, mutating an argument, or performing I/O operations.</p></li>
</ol>

<p>Let&rsquo;s illustrate with JavaScript examples:</p>

<pre><code class="language-javascript">// Pure function
function add(x, y) {
  return x + y;
}

// Impure function (modifies global state)
let globalSum = 0;
function addAndModifyGlobal(x, y) {
  globalSum = x + y;
  return globalSum;
}

// Impure function (mutates input)
function addToArray(arr, value) {
  arr.push(value); // Modifies the original array
  return arr;
}

// Pure function (creates a new array)
function addToArrayPure(arr, value) {
  return [...arr, value]; // Returns a new array without modifying the original
}

// Impure function (side effect: logging to console)
function addAndLog(x, y) {
  console.log(&quot;Adding:&quot;, x, y);
  return x + y;
}
</code></pre>

<p>In the examples above, <code>add</code> is a pure function because its output solely depends on its input and it doesn&rsquo;t alter anything outside its scope.  The other functions are impure due to their side effects: modifying a global variable, mutating an argument, or logging to the console.</p>

<p><strong>Benefits of Pure Functions:</strong></p>

<ul>
<li><p><strong>Testability:</strong> Pure functions are remarkably easy to test.  Given a set of inputs, you can assert the expected output without mocking or managing external dependencies.</p></li>

<li><p><strong>Readability &amp; Maintainability:</strong> The lack of side effects makes pure functions easier to understand and reason about.  Their behavior is self-contained, reducing cognitive load during development.</p></li>

<li><p><strong>Reusability:</strong> Pure functions can be easily reused in different parts of your application because they don&rsquo;t depend on external state.</p></li>

<li><p><strong>Optimizability:</strong> Compilers and runtime environments can optimize pure functions more aggressively, potentially improving performance.  For instance, memoization becomes trivial since the same input always yields the same output.</p></li>
</ul>

<p>By striving to write more pure functions, you enhance the predictability, testability, and maintainability of your frontend code, leading to a more robust and efficient application.</p>
</div>

    </main>
</body>
</html>
