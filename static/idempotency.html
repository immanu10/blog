
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Idempotency</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>05-Feb-2025</time>
</div>
<h1>Idempotency</h1>
<br>
<div id="blog-content"><p>Idempotency is a crucial concept in API design, particularly within a microservices architecture.  It ensures that making the same request multiple times has the same effect as making it once. This is essential for reliable systems because network issues or client retries shouldn&rsquo;t cause unintended side effects.</p>

<p>Think of an elevator call button. Pressing it multiple times doesn&rsquo;t change the outcome – the elevator still arrives at your floor. This is an example of an idempotent operation.</p>

<p><strong>Why is idempotency important for microservices?</strong></p>

<p>In a distributed system like microservices, communication failures are common.  A client might send a request, and due to network hiccups, it&rsquo;s uncertain whether the server received it.  The client might retry the request, potentially causing issues if the operation isn&rsquo;t idempotent.</p>

<p><strong>Example Scenarios:</strong></p>

<ul>
<li><p><strong>Non-Idempotent:</strong>  Imagine an API endpoint for adding an item to a shopping cart. If a client makes this request twice, two items are added. This is <em>not</em> idempotent.</p></li>

<li><p><strong>Idempotent:</strong> Consider an API endpoint for setting a user&rsquo;s preferred language. Sending the same request multiple times (e.g., setting the language to &ldquo;English&rdquo;) has the same result – the language remains &ldquo;English.&rdquo; This <em>is</em> idempotent.</p></li>
</ul>

<p><strong>How to Design Idempotent APIs:</strong></p>

<ol>
<li><p><strong>Unique Request Identification:</strong> Using unique identifiers for each request allows the server to recognize duplicates.  If a client retries a request with the same ID, the server can return the cached result of the original operation.</p></li>

<li><p><strong>PUT vs. POST:</strong>  PUT requests are inherently idempotent because they update a resource at a specific URI.  Making the same PUT request multiple times will always overwrite the resource with the same data. POST requests, however, are generally not idempotent, as they create new resources.  Each POST request results in a new resource being created.</p></li>

<li><p><strong>Conditional Updates:</strong>  For update operations, use conditional checks to ensure idempotency.  For example, include a version number or timestamp in the request. The server will only execute the update if the provided version or timestamp matches the current state of the resource.</p></li>
</ol>

<p><strong>Example using JavaScript and a hypothetical server:</strong></p>

<pre><code class="language-javascript">// Client-side JavaScript
const uniqueRequestId = generateUUID(); // Function to generate a UUID

fetch('/api/user/language', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
    'X-Request-ID': uniqueRequestId, // Include unique request ID in header
  },
  body: JSON.stringify({ language: 'English' }),
})
.then(response =&gt; {
  if (response.status === 200) {
    console.log('Language preference updated successfully.');
  } else if (response.status === 409) { // Conflict - request already processed
    console.log('Request already processed.');
  } else {
    console.error('Failed to update language preference.');
  }
});

// Hypothetical Server-side (Conceptual)
function handleLanguageUpdate(request) {
  const requestId = request.headers['X-Request-ID'];

  // Check if request ID already exists in a database or cache
  if (isRequestProcessed(requestId)) {
    return { status: 409 }; // Return Conflict status
  }

  // Process the request and store the request ID
  updateUserLanguage(request.body.language);
  markRequestProcessed(requestId);

  return { status: 200 };
}
</code></pre>

<p>By implementing these strategies, you can create robust and reliable microservices that handle network failures gracefully and ensure data consistency.</p>
</div>

    </main>
</body>
</html>
