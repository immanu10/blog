
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - TypeScript Narrowing</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>22-Apr-2025</time>
</div>
<h1>TypeScript Narrowing</h1>
<br>
<div id="blog-content"><p>TypeScript&rsquo;s type system is powerful, but sometimes the compiler needs a little help understanding your intentions. This is where type narrowing comes in. Type narrowing allows you to refine the type of a variable within a specific scope, enabling more accurate type checking and preventing runtime errors.</p>

<p>Let&rsquo;s say you have a variable that can be either a string or a number:</p>

<pre><code class="language-typescript">let value: string | number;

value = &quot;hello&quot;;
value = 42;
</code></pre>

<p>If you try to access a string-specific method on <code>value</code>, TypeScript will complain, as it doesn&rsquo;t know for certain that <code>value</code> is a string at that particular point:</p>

<pre><code class="language-typescript">console.log(value.toUpperCase()); // Error: Property 'toUpperCase' does not exist on type 'string | number'.
</code></pre>

<p>Here are several ways to narrow the type:</p>

<p><strong>1. Type Guards:</strong></p>

<p>Type guards are functions that return a boolean indicating whether a variable is of a specific type. The <code>typeof</code> and <code>instanceof</code> operators are common type guards.</p>

<pre><code class="language-typescript">function isString(val: any): val is string {
  return typeof val === &quot;string&quot;;
}

if (isString(value)) {
  console.log(value.toUpperCase()); // No error, value is narrowed to string
}
</code></pre>

<p><strong>2. Equality Narrowing:</strong></p>

<p>Checking for equality with specific values can also narrow the type.</p>

<pre><code class="language-typescript">if (value === &quot;hello&quot;) {
  console.log(value.toUpperCase()); // No error, value is narrowed to string
}
</code></pre>

<p><strong>3. <code>in</code> operator Narrowing:</strong></p>

<p>The <code>in</code> operator can check if a property exists on an object, effectively narrowing the type.</p>

<pre><code class="language-typescript">interface Dog {
  bark: () =&gt; void;
}

interface Cat {
  meow: () =&gt; void;
}

let animal: Dog | Cat;

if (&quot;bark&quot; in animal) {
  animal.bark(); // No error, animal is narrowed to Dog
} else {
  animal.meow(); // No error, animal is narrowed to Cat
}
</code></pre>

<p><strong>4. Discriminated Unions:</strong></p>

<p>Using a common property (a discriminant) in union types helps TypeScript narrow down the type based on the value of the discriminant.</p>

<pre><code class="language-typescript">interface Circle {
  kind: &quot;circle&quot;;
  radius: number;
}

interface Square {
  kind: &quot;square&quot;;
  sideLength: number;
}

type Shape = Circle | Square;

function getArea(shape: Shape) {
  switch (shape.kind) {
    case &quot;circle&quot;:
      return Math.PI * shape.radius ** 2;
    case &quot;square&quot;:
      return shape.sideLength ** 2;
  }
}
</code></pre>

<p>By employing these type narrowing techniques, you can write more robust and type-safe TypeScript code, leveraging the full potential of the type system.  TypeScript will thank you for the extra guidance!</p>
</div>

    </main>
</body>
</html>
