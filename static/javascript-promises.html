
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - JavaScript Promises</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>24-Jan-2025</time>
</div>
<h1>JavaScript Promises</h1>
<br>
<div id="blog-content"><p>Promises are a powerful tool in JavaScript for handling asynchronous operations. They provide a more manageable and cleaner way to deal with the complexities of callbacks, making asynchronous code look and behave a bit more like synchronous code.  A Promise represents the eventual result of an asynchronous operation.  It&rsquo;s in one of three states:</p>

<ul>
<li><strong>Pending:</strong> The initial state, neither fulfilled nor rejected.</li>
<li><strong>Fulfilled:</strong> The operation completed successfully.</li>
<li><strong>Rejected:</strong> The operation failed.</li>
</ul>

<p>A Promise object has a <code>.then()</code> method, which you use to react to the eventual resolution (fulfillment or rejection) of the promise.  You chain <code>.then()</code> calls to create a sequence of asynchronous actions.</p>

<pre><code class="language-javascript">// Create a Promise
const myPromise = new Promise((resolve, reject) =&gt; {
  // Simulate an asynchronous operation (e.g., fetching data)
  setTimeout(() =&gt; {
    const success = true; // Or false to simulate failure
    if (success) {
      resolve(&quot;Data fetched successfully!&quot;); // Resolve with a value
    } else {
      reject(&quot;Data fetching failed.&quot;);      // Reject with a reason
    }
  }, 2000); // Resolve after 2 seconds
});

// Handle the Promise's resolution
myPromise
  .then((data) =&gt; {
    console.log(&quot;Success:&quot;, data);  // Log the resolved value
    return &quot;Further processing...&quot;; // Can return a value or another Promise
  })
  .then((moreData) =&gt; {
    console.log(moreData);       // Log the returned value from the previous .then()
  })
  .catch((error) =&gt; {
    console.error(&quot;Error:&quot;, error); // Log the rejection reason
  });


// Example with a function that returns a promise
function fetchData() {
    return new Promise((resolve, reject) =&gt; {
        fetch('https://api.example.com/data')
          .then(response =&gt; {
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
          })
          .then(data =&gt; {
                resolve(data);
          })
          .catch(error =&gt; {
            reject(error);
          });

    });
}

fetchData()
    .then(data =&gt; {
        console.log('Fetched data:', data);
    })
    .catch(error =&gt; {
        console.error('Error fetching data:', error);
    });

</code></pre>

<p><strong>Explanation:</strong></p>

<ol>
<li><p><strong>Creating a Promise:</strong>  The <code>new Promise()</code> constructor takes a function (called the executor) with two arguments: <code>resolve</code> and <code>reject</code>.  Inside the executor, you perform your asynchronous logic. If the operation is successful, you call <code>resolve()</code> with the result. If it fails, you call <code>reject()</code> with the reason for failure.</p></li>

<li><p><strong>Handling the Result:</strong> <code>.then()</code> takes two optional callback functions: one for success (fulfillment) and one for failure (rejection). You can also chain <code>.then()</code> calls â€“ the return value of one <code>.then()</code> becomes the input to the next.</p></li>

<li><p><strong>Catching Errors:</strong> <code>.catch()</code> handles rejections.  It&rsquo;s equivalent to <code>.then(null, errorHandler)</code>.  It&rsquo;s a best practice to always have a <code>.catch()</code> at the end of your promise chain to handle any errors that might occur during the asynchronous operations.</p></li>
</ol>

<p>Promises significantly simplify asynchronous code in JavaScript, making it more readable and easier to reason about, especially when dealing with multiple asynchronous operations.  They&rsquo;re the foundation of modern asynchronous JavaScript and are essential for writing efficient and maintainable code.</p>
</div>

    </main>
</body>
</html>
