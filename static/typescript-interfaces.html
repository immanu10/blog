
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - TypeScript Interfaces</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>08-Mar-2025</time>
</div>
<h1>TypeScript Interfaces</h1>
<br>
<div id="blog-content"><p>Interfaces in TypeScript are a powerful tool for defining the shape of objects. They act as contracts, ensuring that objects adhere to a specific structure.  This is crucial for maintainability and catching errors during development, especially in larger projects.  Interfaces primarily enhance code clarity and type safety by explicitly specifying the expected properties and methods of objects.</p>

<p><strong>Basic Usage:</strong></p>

<pre><code class="language-typescript">interface Person {
  name: string;
  age: number;
  greet(message: string): string; 
}

let user: Person = {
  name: &quot;John Doe&quot;,
  age: 30,
  greet: function(message: string): string {
    return `${message}, ${this.name}!`;
  }
};

console.log(user.greet(&quot;Hello&quot;)); // Output: Hello, John Doe!


// Error: Property 'greet' is missing in type '{ name: string; age: number; }' but required in type 'Person'.
let badUser: Person = { 
    name: &quot;Jane Doe&quot;, 
    age: 25
}; 
</code></pre>

<p>In this example, <code>Person</code> is an interface defining the structure for a person object.  It mandates that any object assigned to a variable of type <code>Person</code> <em>must</em> have a string property <code>name</code>, a number property <code>age</code>, and a method <code>greet</code> with a specific signature.  Trying to assign an object missing <code>greet</code> (like <code>badUser</code>) results in a compile-time error.</p>

<p><strong>Optional Properties:</strong></p>

<p>Sometimes, not all properties are required. You can mark properties as optional using the <code>?</code> symbol:</p>

<pre><code class="language-typescript">interface Product {
  name: string;
  description?: string; // Optional property
  price: number;
}

let product1: Product = {
  name: &quot;Awesome Gadget&quot;,
  price: 99.99
};

let product2: Product = {
  name: &quot;Another Gadget&quot;,
  description: &quot;This gadget is even more awesome!&quot;,
  price: 129.99
};
</code></pre>

<p><strong>Readonly Properties:</strong></p>

<p>To prevent modification after initialization, use <code>readonly</code>:</p>

<pre><code class="language-typescript">interface Point {
  readonly x: number;
  readonly y: number;
}

let point: Point = { x: 10, y: 20 };

// Error: Cannot assign to 'x' because it is a read-only property.
point.x = 30; 
</code></pre>

<p><strong>Extending Interfaces:</strong></p>

<p>Interfaces can inherit from each other using the <code>extends</code> keyword. This promotes code reuse and creates a clear hierarchy.</p>

<pre><code class="language-typescript">interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square: Square = {
    color: &quot;red&quot;,
    sideLength: 10
};
</code></pre>

<p><strong>Index Signatures:</strong></p>

<p>For objects with an arbitrary number of properties, use index signatures:</p>

<pre><code class="language-typescript">interface StringDictionary {
  [index: string]: string;
}

let myDictionary: StringDictionary = {
  &quot;key1&quot;: &quot;value1&quot;,
  &quot;key2&quot;: &quot;value2&quot;
};

console.log(myDictionary[&quot;key1&quot;]); // Output: value1
</code></pre>

<p><strong>Function Types:</strong></p>

<p>Interfaces can also describe function types:</p>

<pre><code class="language-typescript">interface MathFunction {
  (x: number, y: number): number;
}

let add: MathFunction = (x: number, y: number) =&gt; x + y;
let subtract: MathFunction = (x: number, y: number) =&gt; x - y;

console.log(add(5, 3)); // Output: 8
</code></pre>

<p>By leveraging these features, TypeScript interfaces significantly improve code organization, readability, and maintainability, making them essential for building robust and scalable applications.</p>
</div>

    </main>
</body>
</html>
