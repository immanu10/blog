
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Distributed Locking</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>15-Apr-2025</time>
</div>
<h1>Distributed Locking</h1>
<br>
<div id="blog-content"><p>Distributed locking is a crucial aspect of building robust and reliable distributed systems.  It ensures that shared resources, like databases, file systems, or in-memory data structures, are accessed by only one process or thread at a time, preventing data corruption and race conditions.  In a non-distributed environment, this is typically achieved using mutexes or semaphores.  However, these mechanisms don&rsquo;t work across multiple machines or processes that don&rsquo;t share memory.</p>

<p>Several approaches exist for achieving distributed locking. Let&rsquo;s explore a few common strategies:</p>

<p><strong>1. Redis-Based Locking:</strong></p>

<p>Redis, an in-memory data structure store, offers a simple and effective way to implement distributed locks.  The core idea revolves around using the <code>SETNX</code> (SET if Not eXists) command.  If the key doesn&rsquo;t exist (meaning the lock is free), <code>SETNX</code> sets it and returns 1, indicating success. If the key already exists (lock held by another process), it returns 0.</p>

<pre><code class="language-javascript">const redis = require('redis');

const client = redis.createClient();

async function acquireLock(key, expirySeconds) {
  return new Promise((resolve, reject) =&gt; {
    client.setnx(key, 'locked', 'EX', expirySeconds, (err, reply) =&gt; {
      if (err) {
        reject(err);
      } else {
        resolve(reply === 1); // Returns true if lock acquired, false otherwise
      }
    });
  });
}

async function releaseLock(key) {
  return new Promise((resolve, reject) =&gt; {
    client.del(key, (err, reply) =&gt; {
      if (err) {
        reject(err);
      } else {
        resolve(reply === 1); // Returns true if lock released, false otherwise.
      }
    });
  });
}

// Example usage:
async function doWork() {
    const lockAcquired = await acquireLock(&quot;my_resource&quot;, 10); // Lock for 10 seconds
    if (lockAcquired) {
      console.log(&quot;Lock acquired, performing work...&quot;);
      // ... Perform your critical section work ...
      await releaseLock(&quot;my_resource&quot;);
      console.log(&quot;Lock released.&quot;);
    } else {
      console.log(&quot;Failed to acquire lock.&quot;);
    }
  }

doWork();

</code></pre>

<p>The <code>EX</code> option sets an expiration time for the lock, preventing deadlocks if the holding process crashes before releasing it.</p>

<p><strong>2. Database-Based Locking:</strong></p>

<p>Most relational databases support row-level locking, which can be leveraged to implement distributed locks.  You can create a dedicated table for locks, and acquiring a lock involves inserting a row with the lock identifier.  Releasing the lock involves deleting the corresponding row.</p>

<pre><code class="language-sql">-- Acquire lock
INSERT INTO locks (lock_name) VALUES ('my_resource');

-- Release lock
DELETE FROM locks WHERE lock_name = 'my_resource';
</code></pre>

<p>Transactions should be used to ensure atomicity of acquiring and releasing locks.</p>

<p><strong>3. Distributed Coordination Services (ZooKeeper, etcd):</strong></p>

<p>Specialized distributed coordination services like ZooKeeper and etcd provide more sophisticated locking mechanisms with features like ephemeral nodes (nodes that automatically disappear if the client disconnects) and change notifications. These tools offer higher reliability and flexibility but introduce additional complexity.</p>

<p><strong>Choosing the Right Approach:</strong></p>

<p>The best approach depends on the specific requirements of your application.  Redis is often a good choice for simple scenarios due to its speed and simplicity.  Databases can be suitable when you already have a database infrastructure.  ZooKeeper or etcd are preferable for more complex systems where high availability and advanced features are crucial.</p>
</div>

    </main>
</body>
</html>
