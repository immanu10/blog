
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Monotonic Stack</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>19-Apr-2025</time>
</div>
<h1>Monotonic Stack</h1>
<br>
<div id="blog-content"><p>A monotonic stack is a special type of stack where the elements are either strictly increasing or strictly decreasing. This property allows for efficient solutions to certain problems involving finding the next greater or smaller element in an array.</p>

<p>Let&rsquo;s explore how a monotonic stack works with an example of finding the next greater element for each element in an array.</p>

<p>Consider the array <code>[2, 1, 5, 6, 2, 3]</code>. We want to find the next element to the right that is greater than each element.</p>

<ol>
<li><p><strong>Initialization:</strong> We start with an empty stack.</p></li>

<li><p><strong>Iteration:</strong> We iterate through the array from left to right.</p></li>

<li><p><strong>Stack Operations:</strong></p>

<ul>
<li>If the stack is empty or the current element is less than or equal to the top element of the stack, we push the current element and its index onto the stack. This maintains the monotonically decreasing property.</li>
<li>If the current element is greater than the top element of the stack, we pop elements from the stack until we find an element greater than the current element or the stack becomes empty. For each popped element, the current element is its next greater element.  We then push the current element onto the stack.</li>
</ul></li>

<li><p><strong>Result:</strong> After iterating through the array, the elements remaining in the stack don&rsquo;t have a next greater element to their right.</p></li>
</ol>

<p>Here&rsquo;s a JavaScript implementation:</p>

<pre><code class="language-javascript">function nextGreaterElement(arr) {
  const stack = [];
  const result = new Array(arr.length).fill(-1); // Initialize result with -1

  for (let i = 0; i &lt; arr.length; i++) {
    while (stack.length &gt; 0 &amp;&amp; arr[i] &gt; arr[stack[stack.length - 1]]) {
      const topIndex = stack.pop();
      result[topIndex] = arr[i];
    }
    stack.push(i);
  }

  return result;
}

const arr = [2, 1, 5, 6, 2, 3];
const result = nextGreaterElement(arr);
console.log(result); // Output: [5, 5, 6, -1, 3, -1]
</code></pre>

<p>In this example, for the element <code>2</code> at index <code>0</code>, the next greater element is <code>5</code>. For <code>1</code> at index <code>1</code>, it&rsquo;s also <code>5</code>.  <code>6</code> doesn&rsquo;t have a next greater element, so the result is <code>-1</code>.  And so on.</p>

<p>Monotonic stacks can also be used to find the next smaller element, previous greater element, and previous smaller element.  They are particularly useful in problems involving histograms, largest rectangle in a histogram, and other similar scenarios. They provide an efficient way to maintain a sorted sub-sequence while processing elements, achieving a time complexity of O(n) in many cases.</p>
</div>

    </main>
</body>
</html>
