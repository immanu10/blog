
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Recursion</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>10-Apr-2025</time>
</div>
<h1>Recursion</h1>
<br>
<div id="blog-content"><p>Recursion is a powerful programming technique where a function calls itself within its own definition. This allows for elegant solutions to problems that can be broken down into smaller, self-similar subproblems.  A recursive function typically consists of two parts:</p>

<ol>
<li><p><strong>Base Case:</strong>  The condition that stops the recursion. Without a base case, the function would call itself indefinitely, leading to a stack overflow error.</p></li>

<li><p><strong>Recursive Step:</strong> The part where the function calls itself with a modified input, moving closer to the base case with each call.</p></li>
</ol>

<p>Let&rsquo;s illustrate with a classic example: calculating the factorial of a number.  The factorial of a non-negative integer <code>n</code>, denoted by <code>n!</code>, is the product of all positive integers less than or equal to <code>n</code>.</p>

<pre><code class="language-javascript">function factorial(n) {
  // Base case: factorial of 0 is 1
  if (n === 0) {
    return 1;
  }

  // Recursive step: n! = n * (n-1)!
  return n * factorial(n - 1);
}

console.log(factorial(5)); // Output: 120
</code></pre>

<p>In this example, <code>factorial(5)</code> calculates <code>5 * factorial(4)</code>. <code>factorial(4)</code> then calculates <code>4 * factorial(3)</code>, and so on.  This continues until <code>factorial(0)</code> is reached, which returns 1 (the base case). The values then unwind, multiplying back up the call stack to produce the final result.</p>

<p>Another example is traversing a tree-like data structure:</p>

<pre><code class="language-javascript">const tree = {
  value: 1,
  children: [
    { value: 2, children: [] },
    { value: 3, children: [{ value: 4, children: [] }] },
  ],
};

function printTree(node) {
  console.log(node.value); // Print the current node's value

  // Recursive step: iterate through children and call printTree on each
  for (const child of node.children) {
    printTree(child);
  }
}

printTree(tree); // Output: 1 2 3 4
</code></pre>

<p>Here, <code>printTree</code> visits each node and recursively calls itself on its children. The base case is implicitly when a node has no children â€“ the loop simply doesn&rsquo;t execute.</p>

<p>While recursion can be powerful, it&rsquo;s crucial to design the base case carefully to avoid infinite loops.  Excessive recursion depth can also lead to stack overflow errors.  However, for problems that exhibit self-similarity, recursion offers an elegant and concise solution.</p>
</div>

    </main>
</body>
</html>
