
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - TypeScript Type Guards</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>11-Feb-2025</time>
</div>
<h1>TypeScript Type Guards</h1>
<br>
<div id="blog-content"><p>Type guards are a powerful TypeScript feature that helps you gain more control over types within your conditional logic.  They allow the compiler to understand which type is currently in use within a specific block of code, enabling better type checking and autocompletion.</p>

<p>Let&rsquo;s say you have a variable that can be either a string or a number:</p>

<pre><code class="language-typescript">let value: string | number = &quot;hello&quot;;
</code></pre>

<p>If you try to access string-specific properties without checking the type, TypeScript will complain:</p>

<pre><code class="language-typescript">console.log(value.toUpperCase()); // Error: Property 'toUpperCase' does not exist on type 'string | number'.
</code></pre>

<p>This is where type guards come in. They help you narrow down the type within an <code>if</code> statement or other conditional logic.</p>

<p><strong>1. <code>typeof</code> operator:</strong> The simplest type guard is the <code>typeof</code> operator.</p>

<pre><code class="language-typescript">if (typeof value === &quot;string&quot;) {
  console.log(value.toUpperCase()); // Works!
} else {
  console.log(value.toFixed(2)); // Works assuming value is a number in this branch
}
</code></pre>

<p>Within the <code>if</code> block, TypeScript now knows that <code>value</code> is a string, and in the <code>else</code> block, it infers <code>value</code> as a number.</p>

<p><strong>2. <code>instanceof</code> operator:</strong> Use <code>instanceof</code> to check if a value is an instance of a particular class.</p>

<pre><code class="language-typescript">class Dog {
  bark() {
    console.log(&quot;Woof!&quot;);
  }
}

class Cat {
  meow() {
    console.log(&quot;Meow!&quot;);
  }
}

let pet: Dog | Cat = new Dog();

if (pet instanceof Dog) {
  pet.bark(); // Works!
} else {
  pet.meow(); // Works!
}

</code></pre>

<p><strong>3. User-defined type guards:</strong>  For more complex scenarios, you can create custom type guard functions. These functions must return a type predicate, which is a special return type that tells TypeScript what type a variable is if the function returns <code>true</code>.</p>

<pre><code class="language-typescript">interface Car {
  wheels: number;
  model: string;
}

interface Bicycle {
  wheels: number;
  type: string;
}

function isCar(vehicle: Car | Bicycle): vehicle is Car {
  return (vehicle as Car).model !== undefined;
}

let vehicle: Car | Bicycle = { wheels: 4, model: &quot;Sedan&quot; };

if (isCar(vehicle)) {
  console.log(vehicle.model); // Works!
} else {
  console.log(vehicle.type); // Works!
}

</code></pre>

<p>The <code>vehicle is Car</code> syntax is the type predicate. It asserts that if <code>isCar</code> returns <code>true</code>, the <code>vehicle</code> variable is of type <code>Car</code>.</p>

<p>Using type guards allows you to write more robust and type-safe code, making your TypeScript projects easier to maintain and debug. They empower you to leverage TypeScript&rsquo;s full type checking capabilities even when dealing with complex conditional logic.</p>
</div>

    </main>
</body>
</html>
