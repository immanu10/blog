
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Depth-First Search</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>09-Apr-2025</time>
</div>
<h1>Depth-First Search</h1>
<br>
<div id="blog-content"><p>Depth-first search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking.  Imagine traversing a maze â€“ you&rsquo;d follow one path until you hit a dead end, then retrace your steps to the last intersection and try a different path.  DFS works similarly.</p>

<p>Here&rsquo;s a breakdown of the algorithm and its implementation in JavaScript:</p>

<p><strong>Algorithm:</strong></p>

<ol>
<li><strong>Start at a designated root node.</strong></li>
<li><strong>Mark the current node as visited.</strong></li>
<li><strong>Iterate over the unvisited neighbors of the current node.</strong></li>
<li><strong>For each unvisited neighbor, recursively call the DFS function.</strong></li>
<li><strong>If all neighbors of the current node have been visited, backtrack.</strong></li>
</ol>

<p><strong>JavaScript Implementation:</strong></p>

<pre><code class="language-javascript">function dfs(graph, startNode, visited = new Set()) {
  console.log(`Visiting node: ${startNode}`);
  visited.add(startNode);

  for (const neighbor of graph[startNode]) {
    if (!visited.has(neighbor)) {
      dfs(graph, neighbor, visited);
    }
  }
}


// Example graph represented as an adjacency list
const graph = {
  'A': ['B', 'C'],
  'B': ['D', 'E'],
  'C': ['F'],
  'D': [],
  'E': ['F'],
  'F': []
};

dfs(graph, 'A');
</code></pre>

<p><strong>Explanation:</strong></p>

<ul>
<li>The <code>graph</code> is represented as an adjacency list, where keys are nodes and values are arrays of their neighbors.</li>
<li><code>visited</code> is a Set to keep track of visited nodes, preventing infinite loops in cyclic graphs.</li>
<li>The <code>dfs</code> function recursively calls itself on unvisited neighbors.</li>
</ul>

<p><strong>Output of the example:</strong></p>

<pre><code>Visiting node: A
Visiting node: B
Visiting node: D
Visiting node: E
Visiting node: F
Visiting node: C
Visiting node: F
</code></pre>

<p><strong>Use Cases:</strong></p>

<p>DFS has various applications, including:</p>

<ul>
<li><strong>Finding paths:</strong> Determining if a path exists between two nodes.</li>
<li><strong>Cycle detection:</strong> Identifying cycles in a graph.</li>
<li><strong>Topological sorting:</strong> Ordering nodes in a directed acyclic graph.</li>
<li><strong>Solving puzzles:</strong>  Like maze solving or finding connected components.</li>
</ul>

<p><strong>Time and Space Complexity:</strong></p>

<ul>
<li><strong>Time Complexity:</strong> O(V + E), where V is the number of vertices and E is the number of edges. This is because each node and edge is visited at most once.</li>
<li><strong>Space Complexity:</strong>  O(V) in the worst case due to the recursion stack (in the case of a skewed tree, the maximum depth of the recursion stack will be V).</li>
</ul>

<p>This explanation and code example provides a foundation for understanding and implementing depth-first search in your projects.  Remember to adapt the implementation based on your specific graph representation and requirements.</p>
</div>

    </main>
</body>
</html>
