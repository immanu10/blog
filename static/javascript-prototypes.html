
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - JavaScript Prototypes</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>05-Mar-2025</time>
</div>
<h1>JavaScript Prototypes</h1>
<br>
<div id="blog-content"><p>JavaScript uses prototypes to implement inheritance and shared properties.  Understanding prototypes is crucial for grasping how JavaScript objects work.  This post will explain prototypes and how they relate to object-oriented programming in JavaScript.</p>

<p>Every JavaScript object has an internal, hidden property called <code>[[Prototype]]</code>. This property is a reference to another object, called the prototype. When you try to access a property on an object, and the object itself doesn&rsquo;t have that property, JavaScript will look up the prototype chain. This continues until the property is found or the end of the chain is reached (which is <code>null</code>).</p>

<p>Think of it like looking for a book in a library. You first check the shelf you&rsquo;re at. If it&rsquo;s not there, you might check the next shelf, and so on. If the book isn&rsquo;t in the library at all, the search ends.</p>

<pre><code class="language-javascript">// Create a simple object
const animal = {
  eats: true
};

// Create a new object with 'animal' as its prototype
const rabbit = Object.create(animal);

// Check a property directly on rabbit
console.log(rabbit.eats); // Output: true (Inherited from animal)

// Check if rabbit has its own 'eats' property
console.log(rabbit.hasOwnProperty('eats')); // Output: false

// Add a property to rabbit
rabbit.jumps = true;

console.log(rabbit.jumps); // Output: true
console.log(animal.jumps);  // Output: undefined (animal is not affected)
</code></pre>

<p>In this example, <code>rabbit</code> inherits the <code>eats</code> property from <code>animal</code>. When we access <code>rabbit.eats</code>, JavaScript doesn&rsquo;t find <code>eats</code> directly on <code>rabbit</code>, so it looks up the prototype chain to <code>animal</code>, where it finds the property.</p>

<p><code>Object.create(animal)</code> sets the prototype of <code>rabbit</code> to <code>animal</code>.  You can also access and modify the prototype using <code>__proto__</code> (deprecated) or <code>Object.getPrototypeOf()</code> and <code>Object.setPrototypeOf()</code>. However, directly manipulating the prototype chain is generally discouraged due to performance implications.</p>

<p>Constructor Functions and Prototypes:</p>

<p>Prototypes are also heavily involved in constructor functions, a common way to create objects in JavaScript.</p>

<pre><code class="language-javascript">function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  console.log(this.name + &quot; makes a sound.&quot;);
}

const dog = new Animal(&quot;Buddy&quot;);
dog.speak(); // Output: Buddy makes a sound.
</code></pre>

<p>Here, <code>Animal.prototype</code> is the prototype for all objects created using <code>new Animal()</code>.  By adding <code>speak</code> to <code>Animal.prototype</code>, all instances of <code>Animal</code> inherit the <code>speak</code> method. This is more efficient than adding the method directly to each instance.</p>

<p>Understanding prototypes is fundamental for working effectively with JavaScript objects.  They enable inheritance, help save memory, and are key to understanding how JavaScript implements object-oriented principles.</p>
</div>

    </main>
</body>
</html>
