
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Memoization</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>07-Apr-2025</time>
</div>
<h1>Memoization</h1>
<br>
<div id="blog-content"><p>Memoization is an optimization technique that speeds up applications by storing the results of expensive function calls and returning the cached result when the same inputs occur again.  It&rsquo;s a trade-off of space (to store the cached results) for time (saved by not recalculating).</p>

<p>Think of it like a lookup table. The first time you call a function with specific inputs, the result is calculated and stored in the table.  Subsequent calls with the same inputs skip the calculation and retrieve the result directly from the table.</p>

<p>Here&rsquo;s a JavaScript example demonstrating memoization:</p>

<pre><code class="language-javascript">function expensiveCalculation(n) {
  console.log(`Calculating ${n}!`); // Simulate an expensive operation
  let result = 1;
  for (let i = 2; i &lt;= n; i++) {
    result *= i;
  }
  return result;
}

function memoize(func) {
  const cache = new Map(); // Use a Map to store cached results

  return function(...args) { // Use rest parameters to handle any number of arguments
    const key = JSON.stringify(args); // Create a key from the arguments
    if (cache.has(key)) {
      console.log(`Fetching ${args} from cache`);
      return cache.get(key);
    } else {
      const result = func(...args);
      cache.set(key, result);
      return result;
    }
  };
}


const memoizedCalculation = memoize(expensiveCalculation);

console.log(memoizedCalculation(5)); // Calculates and caches 5!
console.log(memoizedCalculation(5)); // Retrieves 5! from cache
console.log(memoizedCalculation(10)); // Calculates and caches 10!
console.log(memoizedCalculation(5)); // Retrieves 5! from cache again
console.log(memoizedCalculation(10)); // Retrieves 10! from cache
</code></pre>

<p>In this example, <code>memoize</code> is a higher-order function that takes a function (<code>func</code>) and returns a memoized version of it.  The <code>cache</code> object stores the results of previous calculations.  Before performing the expensive calculation, the memoized function checks if the result for the given arguments is already in the cache. If so, it returns the cached result. Otherwise, it calculates the result, stores it in the cache, and then returns it.</p>

<p>The output demonstrates how the expensive calculation is only performed once for each unique set of inputs:</p>

<pre><code>Calculating 5!
120
Fetching 5 from cache
120
Calculating 10!
3628800
Fetching 5 from cache
120
Fetching 10 from cache
3628800
</code></pre>

<p>Memoization is particularly effective for functions with:</p>

<ul>
<li><strong>Expensive computations:</strong> Functions that involve complex calculations, network requests, or database queries can benefit greatly.</li>
<li><strong>Repeated calls with the same inputs:</strong> If a function is called multiple times with the same arguments, memoization avoids redundant computations.  This is often the case in recursive functions or functions used in loops.</li>
</ul>

<p>However, keep in mind that memoization consumes memory to store the cached results.  It&rsquo;s most beneficial when the cost of recalculating is significantly higher than the cost of storing the cached values.  For functions with a large number of possible input combinations, the cache could grow very large, potentially negating the performance benefits.</p>
</div>

    </main>
</body>
</html>
