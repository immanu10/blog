
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - JavaScript Generators</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>21-Mar-2025</time>
</div>
<h1>JavaScript Generators</h1>
<br>
<div id="blog-content"><p>Generators are a special kind of function in JavaScript that can be paused and resumed, allowing you to produce a sequence of values over time without creating an array to store them all at once.  This makes them memory efficient for working with large datasets or infinite sequences.</p>

<p><strong>Defining a Generator:</strong></p>

<p>Generators are defined using an asterisk (<code>*</code>) after the <code>function</code> keyword or before the function name in arrow functions.  They use the <code>yield</code> keyword to return a value and pause execution.</p>

<pre><code class="language-javascript">function* myGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const anotherGenerator = function* () {
  yield 'a';
  yield 'b';
  yield 'c';
};

const arrowGenerator = *() =&gt; {
  yield true;
  yield false;
};
</code></pre>

<p><strong>Using a Generator:</strong></p>

<p>You interact with a generator through its iterator.  Calling the generator function doesn&rsquo;t execute its body. Instead, it returns an iterator object.</p>

<pre><code class="language-javascript">const gen = myGenerator();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }
</code></pre>

<p>Each call to <code>next()</code> on the iterator resumes the generator, executes until the next <code>yield</code>, and returns an object with the yielded <code>value</code> and a <code>done</code> flag indicating whether the generator has finished.</p>

<p><strong>Iterating over a Generator:</strong></p>

<p>You can easily iterate over a generator using a <code>for...of</code> loop:</p>

<pre><code class="language-javascript">for (const value of myGenerator()) {
  console.log(value); // 1, 2, 3
}
</code></pre>

<p><strong>Example: Generating an Infinite Sequence:</strong></p>

<p>Generators are excellent for representing infinite sequences because they generate values on demand.</p>

<pre><code class="language-javascript">function* infiniteCounter() {
  let i = 0;
  while (true) {
    yield i++;
  }
}

const counter = infiniteCounter();

console.log(counter.next().value); // 0
console.log(counter.next().value); // 1
console.log(counter.next().value); // 2
// ... and so on
</code></pre>

<p><strong>Example: Generating Fibonacci Numbers:</strong></p>

<pre><code class="language-javascript">function* fibonacci() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

const fib = fibonacci();

for (let i = 0; i &lt; 10; i++) {
  console.log(fib.next().value); // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
}

</code></pre>

<p>Generators provide a powerful and efficient way to work with sequences of data in JavaScript, especially when dealing with large datasets or infinite sequences. They are a valuable tool for any JavaScript developer to understand.</p>
</div>

    </main>
</body>
</html>
