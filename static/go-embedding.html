
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Go Embedding</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>08-Apr-2025</time>
</div>
<h1>Go Embedding</h1>
<br>
<div id="blog-content"><p>Go&rsquo;s embedding mechanism provides a simple yet powerful way to achieve composition, which allows you to &ldquo;embed&rdquo; a type within another type.  This doesn&rsquo;t create an &ldquo;is-a&rdquo; relationship like inheritance; instead, it creates a &ldquo;has-a&rdquo; relationship where the embedded type&rsquo;s fields and methods become directly accessible on the embedding type.  It&rsquo;s a form of syntactic sugar that promotes code reuse and cleaner interfaces.</p>

<p>Let&rsquo;s illustrate with an example. Imagine building a system for managing different types of users within an application.  Both <code>Admin</code> and <code>RegularUser</code> share common attributes like <code>Name</code> and <code>Email</code>. We can define a <code>User</code> struct to encapsulate these common properties and embed it within <code>Admin</code> and <code>RegularUser</code>:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type User struct {
    Name  string
    Email string
}

func (u *User) Introduce() {
    fmt.Printf(&quot;Hi, I'm %s (%s)\n&quot;, u.Name, u.Email)
}

type Admin struct {
    User
    AccessLevel int
}

type RegularUser struct {
    User
    LastLogin string
}

func main() {
    admin := Admin{
        User: User{
            Name:  &quot;Jane Doe&quot;,
            Email: &quot;jane.doe@example.com&quot;,
        },
        AccessLevel: 10,
    }

    regularUser := RegularUser{
        User: User{
            Name:  &quot;John Smith&quot;,
            Email: &quot;john.smith@example.com&quot;,
        },
        LastLogin: &quot;2024-07-27&quot;,
    }


    fmt.Printf(&quot;Admin: %+v\n&quot;, admin)
    admin.Introduce() // Directly access embedded User's methods

    fmt.Printf(&quot;Regular User: %+v\n&quot;, regularUser)
    regularUser.Introduce()

    fmt.Println(&quot;Admin Access Level:&quot;, admin.AccessLevel) // Access Admin-specific fields
    fmt.Println(&quot;Regular User Last Login:&quot;, regularUser.LastLogin)

    // Access embedded fields directly
    fmt.Println(&quot;Admin Name:&quot;, admin.Name)
    fmt.Println(&quot;Regular User Email:&quot;, regularUser.Email)

}

</code></pre>

<p>In this example, <code>Admin</code> and <code>RegularUser</code> embed the <code>User</code> struct. Notice how we access the <code>Name</code>, <code>Email</code>, and <code>Introduce()</code> method directly on <code>admin</code> and <code>regularUser</code> instances. This is the core benefit of embeddingâ€”it provides a streamlined way to access the embedded type&rsquo;s members.  It also avoids awkward naming conventions like <code>admin.User.Name</code> and promotes cleaner code organization.</p>

<p>Go&rsquo;s embedding offers a powerful mechanism for composition.  It allows you to create complex types by combining simpler ones, promoting code reuse and maintainability. By understanding embedding, you can write more concise and expressive Go code.</p>
</div>

    </main>
</body>
</html>
