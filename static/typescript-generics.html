
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - TypeScript Generics</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>14-Jan-2025</time>
</div>
<h1>TypeScript Generics</h1>
<br>
<div id="blog-content"><p>TypeScript generics allow you to write reusable code components that can work with a variety of types rather than a single one. They provide type safety while maintaining flexibility.  Think of them as templates or blueprints for your types.  This allows you to catch type errors during compilation, leading to more robust code.</p>

<p>Let&rsquo;s illustrate with a simple function to find the identity of a value:</p>

<pre><code class="language-typescript">function identity(arg: any): any {
  return arg;
}

let myString: string = identity(&quot;hello&quot;); 
let myNumber: number = identity(123);
</code></pre>

<p>This function works, but the <code>any</code> type bypasses TypeScript&rsquo;s type checking. If we mistakenly assign the result to the wrong type, we won&rsquo;t get an error at compile time:</p>

<pre><code class="language-typescript">let myString: string = identity(123); // No error at compile time, runtime error!
</code></pre>

<p>This is where generics become valuable. We can rewrite the <code>identity</code> function using a type parameter <code>T</code>:</p>

<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
  return arg;
}

let myString: string = identity&lt;string&gt;(&quot;hello&quot;);
let myNumber: number = identity&lt;number&gt;(123);
let myStringError: string = identity&lt;number&gt;(123); // Compile-time error!
</code></pre>

<p>Now, TypeScript knows the return type based on the input type. Attempting to assign <code>identity&lt;number&gt;(123)</code> to a string variable will result in a compile-time error, preventing potential runtime issues.</p>

<p>Generics are particularly powerful when working with complex data structures.  Consider a function to log the length of an array:</p>

<pre><code class="language-typescript">function logLength&lt;T&gt;(arg: T[]): void {
  console.log(arg.length);
}

logLength&lt;string&gt;([&quot;hello&quot;, &quot;world&quot;]);
logLength&lt;number&gt;([1, 2, 3]);
</code></pre>

<p>Here, <code>T</code> represents the type of elements within the array. The function works with arrays of strings, numbers, or any other type.</p>

<p>You can also use generics with interfaces and classes:</p>

<pre><code class="language-typescript">interface KeyValuePair&lt;K, V&gt; {
  key: K;
  value: V;
}

let stringPair: KeyValuePair&lt;string, string&gt; = { key: &quot;name&quot;, value: &quot;John&quot; };
let numberPair: KeyValuePair&lt;number, string&gt; = { key: 1, value: &quot;Jane&quot; };
</code></pre>

<p>This example demonstrates a <code>KeyValuePair</code> interface that can represent pairs of different types.</p>

<p>In conclusion, TypeScript generics offer a powerful mechanism for writing flexible and type-safe code. By using type parameters, you can create reusable components that adapt to various data types while ensuring type integrity at compile time, which ultimately leads to more reliable and maintainable applications.</p>
</div>

    </main>
</body>
</html>
