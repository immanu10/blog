
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - React useRef</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>13-Apr-2025</time>
</div>
<h1>React useRef</h1>
<br>
<div id="blog-content"><p>The <code>useRef</code> Hook in React provides a way to access a mutable object that persists across renders, similar to how instance variables behave in class components. This mutable object doesn&rsquo;t trigger re-renders when its value changes, making it ideal for scenarios where you need to interact with the DOM directly or store values that don&rsquo;t affect the component&rsquo;s output.</p>

<p>Here&rsquo;s a breakdown of how <code>useRef</code> works and its common use cases:</p>

<pre><code class="language-javascript">import React, { useRef, useEffect } from 'react';

function MyComponent() {
  const inputRef = useRef(null);

  useEffect(() =&gt; {
    // Focus the input element when the component mounts
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, []);

  const handleClick = () =&gt; {
    // Access the current value of the input element
    alert(`Input value: ${inputRef.current.value}`);
  };

  return (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; ref={inputRef} /&gt;
      &lt;button onClick={handleClick}&gt;Get Input Value&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default MyComponent;

</code></pre>

<p><strong>Explanation:</strong></p>

<ol>
<li><p><strong>Creating a Ref:</strong></p>

<ul>
<li><code>const inputRef = useRef(null);</code> creates a mutable ref object.  The initial value is set to <code>null</code>.  This value can be of any type (e.g., an object, a number, a string).</li>
</ul></li>

<li><p><strong>Attaching to a DOM Element:</strong></p>

<ul>
<li><code>&lt;input type=&quot;text&quot; ref={inputRef} /&gt;</code> attaches the ref to the input element. This makes <code>inputRef.current</code> point to the actual DOM node of the input field.</li>
</ul></li>

<li><p><strong>Accessing the DOM Element:</strong></p>

<ul>
<li>Inside <code>useEffect</code>, <code>inputRef.current</code> gives you access to the DOM element, allowing you to call DOM methods like <code>focus()</code>.</li>
<li>In <code>handleClick</code>, <code>inputRef.current.value</code> retrieves the current text typed in the input field.</li>
</ul></li>

<li><p><strong>Persistence Across Renders:</strong></p>

<ul>
<li>The value of <code>inputRef.current</code> persists across renders. Modifying <code>inputRef.current</code> directly doesn&rsquo;t trigger a re-render. This makes it different from state, where changes trigger a re-render.</li>
</ul></li>
</ol>

<p><strong>Common Use Cases:</strong></p>

<ul>
<li><strong>Managing Focus, Text Selection, or Media Playback:</strong>  Control elements imperatively.</li>
<li><strong>Storing Previous Values:</strong> Keep track of a variable&rsquo;s previous value without causing a re-render.</li>
<li><strong>Integrating with Third-Party Libraries:</strong>  Interact with libraries that require direct DOM manipulation.</li>
<li><strong>Creating Mutable Objects for Internal Component Logic:</strong> Store values that don&rsquo;t directly impact the UI.</li>
</ul>

<p><strong>Key Differences from State:</strong></p>

<ul>
<li><strong>No Re-renders:</strong> Modifying <code>ref.current</code> does <em>not</em> cause the component to re-render.</li>
<li><strong>Mutable:</strong>  <code>ref.current</code> is directly mutable. You can change its properties without using a setter function like <code>setState</code>.</li>
</ul>

<p><code>useRef</code> offers a powerful way to manage mutable values and interact with the DOM in a way that complements React&rsquo;s declarative nature. It bridges the gap for scenarios where direct manipulation is necessary without sacrificing performance by causing unnecessary re-renders.</p>
</div>

    </main>
</body>
</html>
