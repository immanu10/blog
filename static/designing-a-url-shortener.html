
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Designing a URL Shortener</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1><a href="/blog">immanu10s blog</h1></a>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://x.com/immanu10x" target="_blank">twitter</a>
        </div>
    </nav>
    <main>

<div>
    <time>03-Jan-2025</time>
</div>
<h1>Designing a URL Shortener</h1>
<br>
<div id="blog-content"><p>A URL shortener, at its core, transforms a long URL into a shorter, more manageable one.  Think bit.ly or tinyurl.com.  While seemingly simple, designing a robust URL shortener involves several interesting considerations.</p>

<p><strong>Core Components:</strong></p>

<ol>
<li><strong>Hashing Algorithm:</strong> This is the heart of the system.  It takes the long URL and generates a unique short code.  Popular choices include MD5, SHA-1, or custom base-62 encoding.  A crucial aspect is minimizing collisions (different long URLs producing the same short code).</li>
</ol>

<pre><code class="language-javascript">   function base62encode(num) {
       const chars = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
       let shortUrl = &quot;&quot;;
       while (num &gt; 0) {
           shortUrl = chars[num % 62] + shortUrl;
           num = Math.floor(num / 62);
       }
       return shortUrl;
   }

   // Example
   const longUrlHash = 1234567890; // Assume this is the output of a hashing function
   const shortCode = base62encode(longUrlHash);
   console.log(shortCode); // Output will be a base62 encoded string.
</code></pre>

<ol>
<li><strong>Storage:</strong>  We need to store the mapping between short codes and original URLs.  Key-value stores like Redis are excellent for fast lookups.  For larger scale, distributed databases might be necessary.  The storage schema could be as simple as:</li>
</ol>

<pre><code>   Key: shortCode
   Value: { originalUrl, creationDate, expirationDate, userId, ... }
</code></pre>

<ol>
<li><strong>API Endpoint:</strong>  This exposes the functionality.  A <code>POST /shorten</code> endpoint accepts the long URL and returns the shortened version.  A <code>GET /{shortCode}</code> endpoint redirects the user to the original URL.</li>
</ol>

<pre><code class="language-javascript">   // Example 'GET' endpoint logic (highly simplified)
   app.get('/:shortCode', (req, res) =&gt; {
       const shortCode = req.params.shortCode;
       // Retrieve original URL from the database based on shortCode
       db.get(shortCode, (err, originalUrl) =&gt; {
           if (err) {
               // Handle error
               return res.status(500).send('Error');
           }
           if (!originalUrl) {
               // Handle short code not found
               return res.status(404).send('Not Found');
           }
           res.redirect(originalUrl);
       });
   });
</code></pre>

<p><strong>Scalability Considerations:</strong></p>

<ul>
<li><strong>Distributed Cache:</strong>  Caching frequently accessed URLs in a distributed cache like Memcached reduces database load.</li>
<li><strong>Sharding:</strong>  Distributing the data across multiple database servers allows horizontal scaling.</li>
<li><strong>Rate Limiting:</strong>  Preventing abuse by limiting the number of requests from a single IP address.</li>
<li><strong>Custom Short Codes:</strong>  Allowing users to customize their short codes (for a fee, perhaps).</li>
</ul>

<p><strong>Further Enhancements:</strong></p>

<ul>
<li>Analytics:  Tracking click-through rates and other metrics.</li>
<li>User Accounts:  Allowing users to manage their shortened URLs.</li>
</ul>

<p>By carefully considering these components, we can design a URL shortener that is not only functional but also scalable and reliable.</p>
</div>

    </main>
</body>
</html>
