
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Designing a URL Shortener</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://x.com/immanu10x" target="_blank">twitter</a>
        </div>
    </nav>
    <main>

<div>
    <time>05-Jan-2025</time>
</div>
<h1>Designing a URL Shortener</h1>
<br>
<div id="blog-content"><p>A URL shortener, at its core, transforms long URLs into shorter, more manageable ones.  Think TinyURL or bit.ly.  Behind the scenes, it&rsquo;s a fascinating exercise in distributed systems design. Let&rsquo;s break down the key components.</p>

<p><strong>1. Hashing:</strong></p>

<p>The heart of a URL shortener is its hashing algorithm.  This algorithm takes an arbitrary input (the long URL) and outputs a fixed-length string. This short string becomes the &ldquo;shortened&rdquo; URL.  Several hashing algorithms are suitable, each with tradeoffs:</p>

<ul>
<li><strong>MD5/SHA-256:</strong>  Cryptographic hashes, excellent for security and collision resistance, but produce longer outputs.  Not ideal for concise short URLs.</li>
<li><strong>MurmurHash/FNV:</strong> Non-cryptographic, optimized for speed and shorter outputs, but with a slightly higher collision risk.</li>
<li><strong>Base62 encoding:</strong>  Crucial for representing the hash as a readable string. It uses a-z, A-Z, and 0-9, allowing for a more compact representation than just hexadecimal.</li>
</ul>

<p>Example in Go:</p>

<pre><code class="language-go">import (
	&quot;crypto/sha256&quot;
	&quot;encoding/base64&quot;
	&quot;fmt&quot;
	&quot;math/big&quot;
)


func shortenURL(longURL string) string {
    hash := sha256.Sum256([]byte(longURL))
		//Base64 encode the hash
		encodedHash := base64.URLEncoding.EncodeToString(hash)
		//For Base 62 a custom implementation is required
		//For demonstration, simply taking a fixed number of characters
		shortURL := encodedHash[:8] //Take first 8 characters
		return shortURL
}


func main() {
	longURL := &quot;https://www.example.com/very/long/url/path&quot;
	shortURL := shortenURL(longURL)
	fmt.Println(&quot;Shortened URL:&quot;, shortURL)
}


</code></pre>

<p><strong>2. Storage:</strong></p>

<p>We need a persistent store to map short URLs back to their original counterparts.  Several options exist:</p>

<ul>
<li><strong>Key-Value Store (Redis, Memcached):</strong>  Excellent for fast lookups, crucial for URL redirection.  Suitable for high read volumes.</li>
<li><strong>Relational Database (MySQL, PostgreSQL):</strong> Offers data integrity and ACID properties, helpful for analytics and managing URL metadata (e.g., creation date, click counts).</li>
</ul>

<p><strong>3. Handling Collisions:</strong></p>

<p>Even with good hashing algorithms, collisions (where two long URLs produce the same short URL) are possible. Strategies for handling them include:</p>

<ul>
<li><strong>Append a counter/random characters:</strong>  If a collision occurs, append a counter or random characters to the hash to make it unique.</li>
<li><strong>Pre-generate short codes:</strong> Avoid collisions entirely by pre-generating unique short codes and assigning them to long URLs as they come in.</li>
</ul>

<p><strong>4. Scalability:</strong></p>

<ul>
<li><strong>Sharding:</strong> Distribute the data across multiple servers to handle high traffic volumes. The short URL can be used to determine the appropriate shard.</li>
<li><strong>Caching:</strong> Employ caching mechanisms at various levels (CDN, server-side) to reduce database load.</li>
<li><strong>Load Balancing:</strong> Distribute traffic across multiple servers handling lookups and redirects.</li>
</ul>

<p><strong>5. Optional Features:</strong></p>

<ul>
<li><strong>Custom Short URLs:</strong> Allow users to customize their short URLs.</li>
<li><strong>Analytics:</strong> Track click-through rates and other metrics.</li>
<li><strong>Expiration:</strong>  Set expiration dates for short URLs.</li>
</ul>

<p>A URL shortener, while seemingly simple, involves a nuanced interplay of hashing, storage, and scalable system design. Understanding these concepts is key to crafting an efficient and robust solution.</p>
</div>

    </main>
</body>
</html>
