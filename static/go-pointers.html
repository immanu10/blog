
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Go Pointers</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>19-Feb-2025</time>
</div>
<h1>Go Pointers</h1>
<br>
<div id="blog-content"><p>Go, unlike Java or Python, offers explicit pointer functionality.  Pointers allow you to directly access and manipulate the memory address of a variable. This can be powerful for performance optimization and working with complex data structures, but also requires careful handling to avoid common pitfalls.</p>

<p>In Go, a pointer is represented by a <code>*</code> preceding the type of the variable it points to.  The <code>&amp;</code> operator obtains the memory address of a variable.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    x := 10 // Declare an integer variable

    var ptr *int  // Declare a pointer to an integer (currently nil)
    ptr = &amp;x     // Assign the address of x to the pointer ptr

    fmt.Println(&quot;Value of x:&quot;, x)          // Output: 10
    fmt.Println(&quot;Address of x:&quot;, &amp;x)       // Output: Memory address (e.g., 0xc000014098)
    fmt.Println(&quot;Value of ptr:&quot;, ptr)       // Output: Memory address (same as above)
    fmt.Println(&quot;Value pointed to by ptr:&quot;, *ptr) // Output: 10 (dereferencing)

    *ptr = 20 // Modify the value at the memory address pointed to by ptr
    fmt.Println(&quot;New value of x:&quot;, x)    // Output: 20 (x is changed!)
}

</code></pre>

<p><strong>Key Concepts:</strong></p>

<ul>
<li><strong>Declaration:</strong> <code>var ptr *int</code> declares a variable named <code>ptr</code> that can hold the memory address of an integer.  The <code>*</code> signifies it&rsquo;s a pointer.</li>
<li><strong>Address-of Operator (<code>&amp;</code>):</strong> <code>ptr = &amp;x</code> takes the memory address of <code>x</code> and assigns it to <code>ptr</code>.</li>
<li><strong>Dereference Operator (<code>*</code>):</strong> <code>*ptr</code> accesses the value stored at the memory address held by <code>ptr</code>.</li>
<li><strong><code>nil</code> Pointers:</strong>  A pointer that doesn&rsquo;t point to anything is <code>nil</code>. Attempting to dereference a <code>nil</code> pointer will cause a runtime error (panic).</li>
</ul>

<p><strong>Example: Modifying a Struct through a Pointer:</strong></p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Person struct {
    Name string
    Age  int
}

func updateAge(p *Person, newAge int) {
    p.Age = newAge
}

func main() {
    person := Person{Name: &quot;Alice&quot;, Age: 30}
    fmt.Println(&quot;Before:&quot;, person) // Output: {Alice 30}

    updateAge(&amp;person, 31) // Pass the address of person
    fmt.Println(&quot;After:&quot;, person)  // Output: {Alice 31}
}
</code></pre>

<p>In this example, <code>updateAge</code> receives a pointer to a <code>Person</code> struct.  Modifying the struct through the pointer directly affects the original <code>person</code> variable.  If <code>updateAge</code> received a copy of the <code>Person</code> struct (without pointers), the changes would be local to the function and wouldn&rsquo;t affect the original.</p>

<p><strong>Caution:</strong></p>

<p>Pointers are powerful, but they require careful management. Incorrect usage can lead to memory leaks, dangling pointers, or segmentation faults. Always ensure you&rsquo;re pointing to valid memory locations and handle <code>nil</code> pointer scenarios gracefully.</p>
</div>

    </main>
</body>
</html>
