
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - TypeScript Mapped Types</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>02-May-2025</time>
</div>
<h1>TypeScript Mapped Types</h1>
<br>
<div id="blog-content"><p>Mapped types in TypeScript allow you to create new types based on existing ones by iterating over their properties and applying a transformation.  They provide a concise way to manipulate and transform type definitions, reducing boilerplate and improving code maintainability.</p>

<p>Let&rsquo;s explore how mapped types work and how they can be useful.</p>

<h3 id="basic-usage">Basic Usage</h3>

<p>Consider an interface representing a user:</p>

<pre><code class="language-typescript">interface User {
  firstName: string;
  lastName: string;
  age: number;
  isActive: boolean;
}
</code></pre>

<p>Suppose you need a new type that represents the same user data but with all properties made optional. You could manually create a new interface, but mapped types offer a more elegant solution:</p>

<pre><code class="language-typescript">type PartialUser = {
  [P in keyof User]?: User[P];
};
</code></pre>

<p>Let&rsquo;s break down this code:</p>

<ul>
<li><code>[P in keyof User]</code> iterates over each property key (<code>firstName</code>, <code>lastName</code>, etc.) in the <code>User</code> interface, assigning each key to the type variable <code>P</code>.</li>
<li><code>User[P]</code> accesses the type of each property using the key <code>P</code>.</li>
<li><code>?</code> makes each property optional in the new <code>PartialUser</code> type.</li>
</ul>

<h3 id="built-in-mapped-types">Built-in Mapped Types</h3>

<p>TypeScript provides several handy built-in mapped types:</p>

<ul>
<li><code>Partial&lt;T&gt;</code>: Makes all properties of <code>T</code> optional.</li>
<li><code>Required&lt;T&gt;</code>: Makes all properties of <code>T</code> required.</li>
<li><code>Readonly&lt;T&gt;</code>: Makes all properties of <code>T</code> read-only.</li>
<li><code>Pick&lt;T, K&gt;</code>: Creates a new type by picking specific properties <code>K</code> from <code>T</code>.</li>
<li><code>Omit&lt;T, K&gt;</code>: Creates a new type by omitting specific properties <code>K</code> from <code>T</code>.</li>
<li><code>Record&lt;K, T&gt;</code>: Defines a new type with keys of type <code>K</code> and values of type <code>T</code>.</li>
</ul>

<p>Using the built-in <code>Partial</code> would simplify our previous example:</p>

<pre><code class="language-typescript">type PartialUser = Partial&lt;User&gt;;
</code></pre>

<h3 id="transforming-property-types">Transforming Property Types</h3>

<p>Mapped types can also transform property types. Let&rsquo;s say you want a type where all string properties of <code>User</code> are converted to uppercase:</p>

<pre><code class="language-typescript">type UppercaseUser = {
  [P in keyof User]: User[P] extends string ? Uppercase&lt;User[P]&gt; : User[P];
};
</code></pre>

<p>Here, we use a conditional type to check if the property type <code>User[P]</code> extends <code>string</code>. If it does, we apply <code>Uppercase&lt;User[P]&gt;</code> to convert it to uppercase. Otherwise, the original property type is retained.</p>

<h3 id="practical-application">Practical Application</h3>

<p>Mapped types are particularly useful when working with forms, data transformations, and creating utility types. For instance, you can use them to define types for API responses, create types for form inputs with validation, or easily transform data between different formats.</p>

<p>By mastering mapped types, you can write more concise, type-safe, and maintainable TypeScript code. They provide powerful tools for manipulating and transforming types, reducing boilerplate, and improving the overall structure of your projects.</p>
</div>

    </main>
</body>
</html>
