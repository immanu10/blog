
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Go Composition</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>15-Mar-2025</time>
</div>
<h1>Go Composition</h1>
<br>
<div id="blog-content"><p>Go, unlike other object-oriented languages like Java or C++, doesn&rsquo;t have classes. Instead, it uses structs and interfaces to achieve similar functionalities, leveraging a powerful concept called composition. Composition in Go focuses on building complex types by combining simpler ones, promoting code reusability and flexibility. This differs from inheritance, where types inherit properties and methods from a parent class.</p>

<p>Let&rsquo;s illustrate with an example. Imagine building a system to represent different types of content, such as blogs and news articles.  We can define individual structs for each:</p>

<pre><code class="language-go">type Author struct {
    Name  string
    Email string
}

type BlogPost struct {
    Title    string
    Content  string
    Author   Author
    Comments []string
}

type NewsArticle struct {
    Headline string
    Body     string
    Author   Author
    Source   string
}
</code></pre>

<p>Notice how both <code>BlogPost</code> and <code>NewsArticle</code> include an <code>Author</code> struct. This is composition in action. Rather than creating a base class and inheriting from it, we embed the <code>Author</code> struct directly, allowing <code>BlogPost</code> and <code>NewsArticle</code> to have an author without explicit inheritance.</p>

<p>We can extend this idea further. Consider adding publishing information:</p>

<pre><code class="language-go">type PublicationInfo struct {
    PublishedDate string
    Publisher     string
}

type BlogPost struct {
    Title         string
    Content       string
    Author        Author
    Comments      []string
    PublicationInfo PublicationInfo
}


type NewsArticle struct {
    Headline       string
    Body          string
    Author        Author
    Source        string
    PublicationInfo PublicationInfo
}
</code></pre>

<p>Now, both types incorporate <code>Author</code> and <code>PublicationInfo</code>. This illustrates the flexibility of composition. You combine the functionalities you need without the rigidity and potential issues of deep inheritance hierarchies.</p>

<p>Accessing embedded fields is straightforward:</p>

<pre><code class="language-go">func main() {
    blog := BlogPost{
        Title: &quot;Go Composition&quot;,
        Content: &quot;Explaining composition...&quot;,
        Author: Author{
            Name:  &quot;John Doe&quot;,
            Email: &quot;john.doe@example.com&quot;,
        },
        PublicationInfo: PublicationInfo{
            PublishedDate: &quot;2024-05-05&quot;,
            Publisher: &quot;Example Blog Site&quot;,
        },
    }

    fmt.Println(&quot;Author Name:&quot;, blog.Author.Name)             // Accessing embedded Author
    fmt.Println(&quot;Published Date:&quot;, blog.PublicationInfo.PublishedDate) // Accessing embedded PublicationInfo

}
</code></pre>

<p>Go&rsquo;s composition approach encourages creating small, focused types that can be combined in various ways. This modularity leads to more maintainable, understandable, and reusable code.</p>
</div>

    </main>
</body>
</html>
