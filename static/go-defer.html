
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Go Defer</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>02-Feb-2025</time>
</div>
<h1>Go Defer</h1>
<br>
<div id="blog-content"><p>Go&rsquo;s <code>defer</code> keyword provides a unique mechanism to schedule function calls to be executed after the surrounding function completes, regardless of whether the function exits successfully or due to a panic. This post will explore <code>defer</code> statements, explaining their behavior and common use cases.</p>

<h3 id="understanding-defer">Understanding <code>defer</code></h3>

<p>The <code>defer</code> keyword is used to postpone the execution of a function until the surrounding function returns. This is particularly useful for cleanup tasks like closing files, releasing resources, or unlocking mutexes.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;
import &quot;os&quot;

func main() {
    f, err := os.Create(&quot;defer.txt&quot;)
    if err != nil {
        panic(err)
    }

    defer f.Close() // Close the file when main() exits

    fmt.Fprintln(f, &quot;Hello, defer!&quot;)
    fmt.Println(&quot;File written successfully.&quot;)
}

</code></pre>

<p>In this example, <code>f.Close()</code> is deferred.  Even if an error occurs during <code>fmt.Fprintln()</code>, the <code>f.Close()</code> function will still be executed before <code>main()</code> returns, ensuring the file is closed properly.</p>

<h3 id="lifo-order">LIFO Order</h3>

<p>When multiple <code>defer</code> statements are present within a function, they are executed in Last-In, First-Out (LIFO) order.  This is analogous to a stack.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    defer fmt.Println(&quot;Third&quot;)
    defer fmt.Println(&quot;Second&quot;)
    defer fmt.Println(&quot;First&quot;)

    fmt.Println(&quot;Main function executing&quot;)
}
</code></pre>

<p>Output:</p>

<pre><code>Main function executing
First
Second
Third
</code></pre>

<h3 id="arguments-and-defer">Arguments and <code>defer</code></h3>

<p>Arguments to deferred functions are evaluated when the <code>defer</code> statement is encountered, not when the deferred function is finally executed.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    i := 1

    defer fmt.Println(i) // Value of i (1) is evaluated here

    i++
    defer fmt.Println(i) // Value of i (2) is evaluated here

    fmt.Println(&quot;Main function executing&quot;)
}

</code></pre>

<p>Output:</p>

<pre><code>Main function executing
2
1
</code></pre>

<p>Even though <code>i</code> is incremented after the first <code>defer</code>, the first deferred function still prints <code>1</code> because the argument was evaluated at the time of the <code>defer</code> statement.</p>

<h3 id="practical-uses">Practical Uses</h3>

<p><code>defer</code> simplifies resource management significantly. Consider scenarios like database connections, network sockets, or mutex locks. Using <code>defer</code> ensures these resources are released promptly, even if errors occur. It makes the code cleaner and less prone to resource leaks.</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func main() {
    var mu sync.Mutex

    mu.Lock()
    defer mu.Unlock() // Ensure mutex is unlocked when function exits

    // Access shared resource protected by the mutex
    fmt.Println(&quot;Accessing shared resource&quot;)

}

</code></pre>

<p>In this example, <code>defer mu.Unlock()</code> guarantees the mutex is unlocked after the function completes, preventing deadlocks.</p>

<p>By understanding and effectively utilizing <code>defer</code>, Go developers can write more robust, cleaner, and efficient code by simplifying resource management and ensuring proper cleanup, even in the face of unexpected errors.</p>
</div>

    </main>
</body>
</html>
