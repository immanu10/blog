
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immanu10 - Backtracking</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <h1 id="logo">
            <a href="/blog">immanu10s blog</a>
            <span>*All blogs are generated by AI</span>
        </h1>
        <div>
            <a href="https://github.com/immanu10/" target="_blank">github</a>
            <a href="https://www.linkedin.com/in/immanu10" target="_blank">linkedin</a>
        </div>
    </nav>
    <main>

<div>
    <time>20-Jan-2025</time>
</div>
<h1>Backtracking</h1>
<br>
<div id="blog-content"><p>Backtracking is a powerful algorithmic technique used to solve problems that involve exploring a search space to find a solution. It works by incrementally building a solution, one step at a time. If a partial solution is found to be invalid or does not lead to a complete solution, the algorithm &ldquo;backtracks&rdquo; to the previous step and tries a different path.  Think of it as exploring a maze – if you hit a dead end, you retrace your steps and try a different route.</p>

<p><strong>How Backtracking Works</strong></p>

<p>Backtracking employs a recursive approach and typically follows these steps:</p>

<ol>
<li><p><strong>Base Case:</strong>  Define a condition that indicates whether a solution has been found or if the search space has been exhausted. This is the termination condition for the recursion.</p></li>

<li><p><strong>Choices:</strong> At each step, identify the possible choices or decisions that can be made.</p></li>

<li><p><strong>Constraints:</strong> Implement rules or conditions that determine if a choice is valid or feasible. This prevents exploring dead ends.</p></li>

<li><p><strong>Recursion:</strong> For each valid choice, recursively call the backtracking function to explore the next step in the search space.</p></li>

<li><p><strong>Backtracking:</strong> If a recursive call returns without finding a solution, undo the choice made in the current step (i.e., backtrack) and try the next available choice.</p></li>
</ol>

<p><strong>Example: N-Queens Problem</strong></p>

<p>The N-Queens problem is a classic example where backtracking is effective. The goal is to place N chess queens on an N×N chessboard such that no two queens threaten each other (no two queens share the same row, column, or diagonal).</p>

<pre><code class="language-javascript">function isSafe(board, row, col, N) {
  for (let i = 0; i &lt; row; i++) {
    if (board[i] === col || Math.abs(board[i] - col) === row - i) {
      return false;
    }
  }
  return true;
}

function solveNQueensUtil(board, row, N, solutions) {
  if (row === N) {
    solutions.push([...board]); // Found a solution, add a copy
    return;
  }

  for (let col = 0; col &lt; N; col++) {
    if (isSafe(board, row, col, N)) {
      board[row] = col;
      solveNQueensUtil(board, row + 1, N, solutions);
      // Backtrack implicitly – no need to reset board[row] as next loop iteration overwrites
    }
  }
}

function solveNQueens(N) {
  const board = new Array(N);
  const solutions = [];
  solveNQueensUtil(board, 0, N, solutions);
  return solutions;
}

const solutions = solveNQueens(4);
console.log(solutions);
</code></pre>

<p><strong>Explanation</strong></p>

<ul>
<li><code>isSafe()</code>: Checks if placing a queen at <code>(row, col)</code> is safe.</li>
<li><code>solveNQueensUtil()</code>: The recursive backtracking function. It tries placing a queen in each column of the current row.</li>
<li><code>solveNQueens()</code>: Initializes the board and starts the backtracking process.</li>
</ul>

<p><strong>Key Advantages of Backtracking</strong></p>

<ul>
<li><strong>Simplicity:</strong>  Relatively easy to implement.</li>
<li><strong>Versatility:</strong>  Can be adapted to various problems.</li>
<li><strong>Finding All Solutions:</strong> Can be used to find all possible solutions or a single solution.</li>
</ul>

<p><strong>Limitations</strong></p>

<ul>
<li><strong>Time Complexity:</strong> Can be computationally expensive for larger search spaces, potentially leading to exponential time complexity.</li>
<li><strong>Memory Usage:</strong>  Recursive calls can consume significant stack space, especially for deep recursion.</li>
</ul>

<p>Backtracking is a fundamental technique in problem-solving. Understanding its core principles opens up possibilities to tackle a wide range of challenges effectively.</p>
</div>

    </main>
</body>
</html>
